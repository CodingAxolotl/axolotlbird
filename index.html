<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Axolotl Bird</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #e0f2fe; /* Light blue background */
        }
        canvas {
            border-radius: 1rem;
            background-color: #7dd3fc; /* Sky blue */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            touch-action: none; /* Prevent browser scrolling on touch devices */
        }
        #game-container {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        .message-box {
            background-color: #ffffff;
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .start-btn, .restart-btn, .consent-btn {
            background-color: #6ee7b7; /* Green for start/restart */
            color: #1f2937;
            font-weight: bold;
            padding: 0.75rem 1.5rem;
            border-radius: 9999px; /* Fully rounded */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .start-btn:hover, .restart-btn:hover, .consent-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px -1px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">
    <div id="game-container" class="w-full max-w-lg flex flex-col items-center">
        <!-- Game Canvas -->
        <canvas id="gameCanvas" class="w-full max-w-full aspect-video md:h-[600px]"></canvas>

        <!-- Start Screen / Game Over Screen -->
        <div id="message-box" class="absolute inset-0 flex items-center justify-center p-4 bg-gray-900 bg-opacity-70 rounded-xl m-8 hidden">
            <div class="message-box p-8 rounded-xl text-center shadow-lg">
                <h2 id="message-text" class="text-4xl font-extrabold mb-4 text-gray-800">Welcome!</h2>
                <div id="buttons-container" class="flex justify-center space-x-4">
                    <!-- Buttons will be dynamically added here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        window.onload = function() {
            // Get the canvas and its context
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const messageBox = document.getElementById('message-box');
            const messageText = document.getElementById('message-text');
            const buttonsContainer = document.getElementById('buttons-container');

            // Set initial canvas size
            const floorHeight = 50; // The height of the grass floor
            function resizeCanvas() {
                canvas.width = canvas.parentElement.offsetWidth;
                canvas.height = canvas.parentElement.offsetHeight;
            }
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Game constants and state variables
            let score = 0;
            let highScore = 0;
            let hasConsent = false;
            let gameSpeed = 3; // Initial base speed
            const maxGameSpeed = 6; // Maximum speed the game can reach
            const speedIncreaseFactor = 0.01; // How much speed increases per score point
            let lines = [];
            let clouds = [];
            let gameOver = false;
            const minDistanceBetweenLines = 400; // Increased minimum horizontal distance between lines
            const minCloudDistance = 300; // Decreased minimum horizontal distance between clouds
            const minVerticalClearance = 100; // Minimum vertical space from top and bottom walls
            
            // Power-up/Debuff state
            let currentEffect = null;
            let effectEndTime = 0;
            const effectDuration = 5000; // 5 seconds

            // Axolotl Bird SVG
            const axolotlSVG = `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" fill="#ff7f50">
                <g transform="scale(0.8) translate(10, 10)">
                    <!-- Body -->
                    <path d="M 50 80 Q 40 95 30 80 Q 20 65 30 50 Q 40 35 50 50 Z" stroke="#333" stroke-width="2" fill="#ff7f50"/>
                    <!-- Head -->
                    <path d="M 50 50 Q 60 40 70 50 Q 80 60 70 70 Z" stroke="#333" stroke-width="2" fill="#ffb4a2"/>
                    <!-- Gills -->
                    <circle cx="65" cy="40" r="5" fill="#f08080" stroke="#333" stroke-width="1"/>
                    <circle cx="60" cy="30" r="5" fill="#f08080" stroke="#333" stroke-width="1"/>
                    <circle cx="70" cy="30" r="5" fill="#f08080" stroke="#333" stroke-width="1"/>
                    <!-- Eye -->
                    <circle cx="68" cy="55" r="3" fill="#333"/>
                    <!-- Wings -->
                    <path d="M 40 45 Q 30 30 15 40 Q 20 50 35 55 Z" stroke="#333" stroke-width="1" fill="#f4a261"/>
                    <path d="M 45 60 Q 35 75 20 65 Q 25 80 40 70 Z" stroke="#333" stroke-width="1" fill="#f4a261"/>
                </g>
            </svg>`;

            const axolotlImg = new Image();
            const svgBlob = new Blob([axolotlSVG], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(svgBlob);
            axolotlImg.src = url;

            // Axolotl Bird object
            const axolotl = {
                x: 100,
                y: canvas.height / 2,
                width: 60,
                height: 60,
                velocity: 0,
                gravity: 0.3,
                jumpPower: -5, // Reduced jump power
                rotation: 0,
                onLine: false, // Tracks if the axolotl is currently on a line

                draw: function() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.rotation);
                    ctx.drawImage(axolotlImg, -this.width / 2, -this.height / 2, this.width, this.height);
                    ctx.restore();
                    
                    // Draw shield if active
                    if (currentEffect === 'shield') {
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.width / 2 + 5, 0, Math.PI * 2);
                        ctx.strokeStyle = 'rgba(0, 255, 0, 0.7)';
                        ctx.lineWidth = 5;
                        ctx.stroke();
                    }
                },

                update: function() {
                    this.y += this.velocity;
                    this.rotation = Math.min(Math.PI / 4, this.velocity * 0.1);
                },

                jump: function() {
                    // Allow the axolotl to jump at any time to "fly"
                    this.velocity = this.jumpPower;
                    this.onLine = false;
                }
            };

            // Line Obstacle object
            class LineObstacle {
                constructor() {
                    this.x = canvas.width;
                    // Adjusted vertical position to ensure lines are not too high or low
                    const maxLineY = canvas.height - floorHeight - minVerticalClearance;
                    const minLineY = minVerticalClearance;
                    this.y = minLineY + Math.random() * (maxLineY - minLineY);
                    this.width = 150;
                    this.height = 10;
                    this.isScored = false; // Tracks if a point has been scored for this line
                }

                draw() {
                    ctx.fillStyle = '#65a30d'; // Green for the line
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                }

                update(speed) {
                    this.x -= speed;
                }
            }

            // Cloud object
            class Cloud {
                constructor() {
                    this.x = canvas.width;
                    // Adjusted cloud generation to be in a similar vertical range as lines
                    const maxCloudY = canvas.height - floorHeight - minVerticalClearance;
                    const minCloudY = minVerticalClearance;
                    this.y = minCloudY + Math.random() * (maxCloudY - minCloudY);
                    this.radius = 20;
                    const cloudTypes = ['green', 'yellow', 'red'];
                    this.type = cloudTypes[Math.floor(Math.random() * cloudTypes.length)];
                }

                draw() {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    switch(this.type) {
                        case 'green':
                            ctx.fillStyle = 'rgba(0, 255, 0, 0.8)';
                            break;
                        case 'yellow':
                            ctx.fillStyle = 'rgba(255, 255, 0, 0.8)';
                            break;
                        case 'red':
                            ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                            break;
                    }
                    ctx.fill();
                }

                update(speed) {
                    this.x -= speed;
                }
            }

            // Function to check for a bounding box collision between two objects
            function checkCollision(obj1, obj2) {
                // Get the bounding box for the axolotl
                const axolotlRect = {
                    x: obj1.x - obj1.width / 2,
                    y: obj1.y - obj1.height / 2,
                    width: obj1.width,
                    height: obj1.height
                };

                // Get the bounding box for the line
                const lineRect = {
                    x: obj2.x,
                    y: obj2.y,
                    width: obj2.width,
                    height: obj2.height
                };

                // Check for overlap on x and y axes
                return axolotlRect.x < lineRect.x + lineRect.width &&
                       axolotlRect.x + axolotlRect.width > lineRect.x &&
                       axolotlRect.y < lineRect.y + lineRect.height &&
                       axolotlRect.y + axolotlRect.height > lineRect.y;
            }
            
            // The main game loop
            function gameLoop() {
                if (gameOver) {
                    return;
                }

                // Check for effect expiration
                const currentTime = performance.now();
                if (currentTime > effectEndTime) {
                    currentEffect = null;
                }
                
                // Adjust game speed based on slowness effect and score
                let currentSpeed = Math.min(gameSpeed + score * speedIncreaseFactor, maxGameSpeed);
                if (currentEffect === 'slowness') {
                    currentSpeed /= 2;
                }
                
                // Reset onLine state at the beginning of the frame
                axolotl.onLine = false;

                // Update axolotl's position and apply gravity
                axolotl.y += axolotl.velocity;
                axolotl.velocity += axolotl.gravity;

                // Clear the canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Apply blindness effect drawing
                if (currentEffect === 'blindness') {
                    // Draw a black overlay
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Create a circular "hole" to see through
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.beginPath();
                    ctx.arc(axolotl.x, axolotl.y, 80, 0, Math.PI * 2); // 80px radius of vision
                    ctx.fillStyle = '#000000';
                    ctx.fill();
                    ctx.globalCompositeOperation = 'source-over';
                }

                // Draw the grass floor
                ctx.fillStyle = '#22c55e'; // Green grass
                ctx.fillRect(0, canvas.height - floorHeight, canvas.width, floorHeight);

                // Draw the score and current effect text
                ctx.fillStyle = '#1f2937';
                ctx.font = 'bold 3rem Inter, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(score, canvas.width / 2, 50);

                if (currentEffect) {
                    let effectText = '';
                    switch (currentEffect) {
                        case 'shield': effectText = 'Shield Active!'; break;
                        case 'slowness': effectText = 'Slowness!'; break;
                        case 'blindness': effectText = 'Blindness!'; break;
                    }
                    ctx.font = 'bold 1.5rem Inter, sans-serif';
                    ctx.fillText(effectText, canvas.width / 2, 85);
                }

                // Check for ground and ceiling collision
                if (axolotl.y > canvas.height - floorHeight - axolotl.height / 2 || axolotl.y < axolotl.height / 2) {
                    // Check if the shield is active
                    if (currentEffect === 'shield') {
                        // Shield is used up, so remove the effect
                        currentEffect = null;
                        effectEndTime = 0;
                    } else {
                        endGame('You hit an obstacle!');
                        return;
                    }
                }
                
                // Generate a new line if needed
                if (lines.length === 0 || canvas.width - lines[lines.length-1].x > minDistanceBetweenLines) {
                    lines.push(new LineObstacle());
                }

                // Process lines for this frame
                let nextLines = [];
                for (const line of lines) {
                    line.update(currentSpeed);
                    
                    // Collision detection with the line
                    if (checkCollision(axolotl, line)) {
                        // Check if the collision is a "landing"
                        if (axolotl.velocity >= 0 && axolotl.y - axolotl.height/2 < line.y + line.height) {
                            axolotl.velocity = 0;
                            axolotl.y = line.y - axolotl.height / 2; // Snap to the top of the line
                            axolotl.onLine = true;
                        } else {
                            // If it's a collision from the side or below, use the shield or end the game
                            if (currentEffect === 'shield') {
                                // Shield is used up, so remove the effect
                                currentEffect = null;
                                effectEndTime = 0;
                            } else {
                                endGame('You hit an obstacle!');
                                return;
                            }
                        }
                    }

                    // NEW SCORING LOGIC: Check if the axolotl has successfully flown past the line
                    if (axolotl.x - axolotl.width / 2 > line.x + line.width && !line.isScored) {
                        score++;
                        line.isScored = true;
                    }
                    
                    line.draw();
                    
                    // Keep the line if it is still on screen
                    if (line.x + line.width > 0) {
                        nextLines.push(line);
                    }
                }
                lines = nextLines;
                
                // Generate a new cloud if needed
                if (clouds.length === 0 || canvas.width - clouds[clouds.length-1].x > minCloudDistance) {
                    clouds.push(new Cloud());
                }

                // Process clouds for this frame
                let nextClouds = [];
                for (const cloud of clouds) {
                    cloud.update(currentSpeed);

                    // Collision detection with cloud
                    const dx = axolotl.x - cloud.x;
                    const dy = axolotl.y - cloud.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < axolotl.width / 2 + cloud.radius) {
                        // Apply new effect only if no other effect is currently active
                        if (currentEffect === null) {
                            switch(cloud.type) {
                                case 'green':
                                    currentEffect = 'shield';
                                    break;
                                case 'yellow':
                                    currentEffect = 'slowness';
                                    break;
                                case 'red':
                                    currentEffect = 'blindness';
                                    break;
                            }
                            effectEndTime = currentTime + effectDuration;
                        }
                    } else {
                        nextClouds.push(cloud);
                    }
                    
                    cloud.draw();
                }
                clouds = nextClouds;
                
                // Update axolotl's rotation after its velocity is finalized
                axolotl.rotation = Math.min(Math.PI / 4, axolotl.velocity * 0.1);

                // Draw the axolotl
                axolotl.draw();

                requestAnimationFrame(gameLoop);
            }

            // Game over function
            function endGame(reason) {
                gameOver = true;
                if (hasConsent && score > highScore) {
                    highScore = score;
                    localStorage.setItem('axolotlHighScore', highScore);
                    messageText.innerHTML = `Game Over! <br> ${reason} <br> New High Score: ${highScore}`;
                } else {
                     messageText.innerHTML = `Game Over! <br> ${reason} <br> Your score: ${score}<br>High Score: ${highScore}`;
                }
                buttonsContainer.innerHTML = `<button id="restartButton" class="restart-btn">Restart</button>`;
                messageBox.classList.remove('hidden');
                document.getElementById('restartButton').addEventListener('click', () => {
                    startGame();
                });
            }

            // Start game function
            function startGame() {
                gameOver = false;
                score = 0;
                lines = [];
                clouds = [];
                axolotl.y = canvas.height / 2;
                axolotl.velocity = 0;
                axolotl.onLine = false;
                
                // Reset effects
                currentEffect = null;
                effectEndTime = 0;
                gameSpeed = 3;
                
                // Add the first line immediately to start the game properly
                lines.push(new LineObstacle());

                messageBox.classList.add('hidden');
                requestAnimationFrame(gameLoop);
            }
            
            function handleJump() {
                if (!gameOver) {
                    axolotl.jump();
                }
            }
            
            canvas.addEventListener('mousedown', handleJump);
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                handleJump();
            });

            function showConsentDialog() {
                messageText.innerHTML = `This game would like to save your best score on your device. Is that okay?`;
                buttonsContainer.innerHTML = `
                    <button id="yesButton" class="consent-btn">Yes</button>
                    <button id="noButton" class="consent-btn">No</button>
                `;
                messageBox.classList.remove('hidden');

                document.getElementById('yesButton').addEventListener('click', () => {
                    localStorage.setItem('hasGivenConsent', 'yes');
                    hasConsent = true;
                    loadHighScore();
                    showStartScreen();
                });
                
                document.getElementById('noButton').addEventListener('click', () => {
                    localStorage.setItem('hasGivenConsent', 'no');
                    hasConsent = false;
                    showStartScreen();
                });
            }
            
            function loadHighScore() {
                const storedHighScore = localStorage.getItem('axolotlHighScore');
                if (storedHighScore !== null) {
                    highScore = parseInt(storedHighScore, 10);
                }
            }
            
            function showStartScreen() {
                const welcomeMessage = hasConsent ? 
                    `Welcome back! <br> High Score: ${highScore}` : 
                    `Welcome!`;
                messageText.innerHTML = welcomeMessage;
                buttonsContainer.innerHTML = `<button id="startButton" class="start-btn">Start Game</button>`;
                document.getElementById('startButton').addEventListener('click', startGame);
                messageBox.classList.remove('hidden');
            }

            // Initial setup on load
            const consentStatus = localStorage.getItem('hasGivenConsent');
            if (consentStatus === null) {
                showConsentDialog();
            } else if (consentStatus === 'yes') {
                hasConsent = true;
                loadHighScore();
                showStartScreen();
            } else {
                hasConsent = false;
                showStartScreen();
            }
        };
    </script>
</body>
</html>
